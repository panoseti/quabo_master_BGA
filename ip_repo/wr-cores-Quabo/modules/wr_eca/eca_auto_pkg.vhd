--! @file        eca_auto_pkg.vhd
--  DesignUnit   eca_auto
--! @author      Wesley W. Terpstra <w.terpstra@gsi.de>
--! @date        08/04/2016
--! @version     2.0
--! @copyright   2016 GSI Helmholtz Centre for Heavy Ion Research GmbH
--!

--! @brief AUTOGENERATED WISHBONE-SLAVE PACKAGE FOR eca.vhd
--!
--------------------------------------------------------------------------------
--! This library is free software; you can redistribute it and/or
--! modify it under the terms of the GNU Lesser General Public
--! License as published by the Free Software Foundation; either
--! version 3 of the License, or (at your option) any later version.
--!
--! This library is distributed in the hope that it will be useful,
--! but WITHOUT ANY WARRANTY; without even the implied warranty of
--! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--! Lesser General Public License for more details.
--!
--! You should have received a copy of the GNU Lesser General Public
--! License along with this library. If not, see <http://www.gnu.org/licenses/>.
--------------------------------------------------------------------------------

-- ***********************************************************
-- ** WARNING - THIS IS AUTO-GENERATED CODE! DO NOT MODIFY! **
-- ***********************************************************
--
-- If you want to change the interface,
-- modify eca.xml and re-run 'python wbgenplus.py eca.xml' !

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.wishbone_pkg.all;
use work.wbgenplus_pkg.all;
use work.genram_pkg.all;
package eca_auto_pkg is

  constant c_channels_GET               : natural := 16#00#;  -- ro,  8 b, Number of channels implemented by the ECA, including the internal IO channel #0
  constant c_search_capacity_GET        : natural := 16#04#;  -- ro, 16 b, Total number of search table entries per active page
  constant c_walker_capacity_GET        : natural := 16#08#;  -- ro, 16 b, Total number of walker table entries per active page
  constant c_latency_GET                : natural := 16#0c#;  -- ro, 32 b, Delay in ticks (typically nanoseconds) between an event's arrival at the ECA and its earliest possible execution as an action
  constant c_offset_bits_GET            : natural := 16#10#;  -- ro,  8 b, Actions scheduled for execution with a delay in ticks exceeding offset_bits are executed early
  constant c_flip_active_OWR            : natural := 16#14#;  -- wo,  1 b, Flip the active search and walker tables with the inactive tables
  constant c_time_hi_GET                : natural := 16#18#;  -- ro, 32 b, Ticks (nanoseconds) since Jan 1, 1970 (high word)
  constant c_time_lo_GET                : natural := 16#1c#;  -- ro, 32 b, Ticks (nanoseconds) since Jan 1, 1970 (low word)
  constant c_search_select_RW           : natural := 16#20#;  -- rw, 16 b, Read/write this record in the inactive search table
  constant c_search_rw_first_RW         : natural := 16#24#;  -- rw, 16 b, Scratch register to be written to search_ro_first
  constant c_search_rw_event_hi_RW      : natural := 16#28#;  -- rw, 32 b, Scratch register to be written to search_ro_event_hi
  constant c_search_rw_event_lo_RW      : natural := 16#2c#;  -- rw, 32 b, Scratch register to be written to search_ro_event_lo
  constant c_search_write_OWR           : natural := 16#30#;  -- wo,  1 b, Store the scratch registers to the inactive search table record search_select
  constant c_search_ro_first_GET        : natural := 16#34#;  -- ro, 16 b, The first walker entry to execute if an event matches this record in the search table
  constant c_search_ro_event_hi_GET     : natural := 16#38#;  -- ro, 32 b, Event IDs greater than or equal to this value match this search table record (high word)
  constant c_search_ro_event_lo_GET     : natural := 16#3c#;  -- ro, 32 b, Event IDs greater than or equal to this value match this search table record (low word)
  constant c_walker_select_RW           : natural := 16#40#;  -- rw, 16 b, Read/write this record in the inactive walker table
  constant c_walker_rw_next_RW          : natural := 16#44#;  -- rw, 16 b, Scratch register to be written to walker_ro_next
  constant c_walker_rw_offset_hi_RW     : natural := 16#48#;  -- rw, 32 b, Scratch register to be written to walker_ro_offset_hi
  constant c_walker_rw_offset_lo_RW     : natural := 16#4c#;  -- rw, 32 b, Scratch register to be written to walker_ro_offset_lo
  constant c_walker_rw_tag_RW           : natural := 16#50#;  -- rw, 32 b, Scratch register to be written to walker_ro_tag
  constant c_walker_rw_flags_RW         : natural := 16#54#;  -- rw,  4 b, Scratch register to be written to walker_ro_flags
  constant c_walker_rw_channel_RW       : natural := 16#58#;  -- rw,  8 b, Scratch register to be written to walker_ro_channel
  constant c_walker_rw_num_RW           : natural := 16#5c#;  -- rw,  8 b, Scratch register to be written to walker_ro_num
  constant c_walker_write_OWR           : natural := 16#60#;  -- wo,  1 b, Store the scratch registers to the inactive walker table record walker_select
  constant c_walker_ro_next_GET         : natural := 16#64#;  -- ro, 16 b, The next walker entry to execute after this record (0xffff = end of list)
  constant c_walker_ro_offset_hi_GET    : natural := 16#68#;  -- ro, 32 b, The resulting action's deadline is the event timestamp plus this offset (high word)
  constant c_walker_ro_offset_lo_GET    : natural := 16#6c#;  -- ro, 32 b, The resulting action's deadline is the event timestamp plus this offset (low word)
  constant c_walker_ro_tag_GET          : natural := 16#70#;  -- ro, 32 b, The resulting actions's tag
  constant c_walker_ro_flags_GET        : natural := 16#74#;  -- ro,  4 b, Execute the resulting action even if it suffers from the errors set in this flag register
  constant c_walker_ro_channel_GET      : natural := 16#78#;  -- ro,  8 b, The channel to which the resulting action will be sent
  constant c_walker_ro_num_GET          : natural := 16#7c#;  -- ro,  8 b, The subchannel to which the resulting action will be sent
  constant c_channel_select_RW          : natural := 16#80#;  -- rw,  8 b, Read/clear this channel
  constant c_channel_num_select_RW      : natural := 16#84#;  -- rw,  8 b, Read/clear this subchannel
  constant c_channel_code_select_RW     : natural := 16#88#;  -- rw,  2 b, Read/clear this error condition (0=late, 1=early, 2=conflict, 3=delayed)
  constant c_channel_type_GET           : natural := 16#90#;  -- ro, 32 b, Type of the selected channel (0=io, 1=linux, 2=wbm, ...)
  constant c_channel_max_num_GET        : natural := 16#94#;  -- ro,  8 b, Total number of subchannels supported by the selected channel
  constant c_channel_capacity_GET       : natural := 16#98#;  -- ro, 16 b, Total number of actions which may be enqueued by the selected channel at a time
  constant c_channel_msi_set_enable_OWR : natural := 16#9c#;  -- wo,  1 b, Turn on/off MSI messages for the selected channel
  constant c_channel_msi_get_enable_GET : natural := 16#a0#;  -- ro,  1 b, Check if MSI messages are enabled for the selected channel
  constant c_channel_msi_set_target_OWR : natural := 16#a4#;  -- wo, 32 b, Set the destination MSI address for the selected channel (only possible while it has MSIs disabled)
  constant c_channel_msi_get_target_GET : natural := 16#a8#;  -- ro, 32 b, Get the destination MSI address for the selected channel
  constant c_channel_mostfull_ack_GET   : natural := 16#ac#;  -- ro, 32 b, Read the selected channel's fill status (used_now<<16 | used_most), MSI=(6<<16) will be sent if used_most changes
  constant c_channel_mostfull_clear_GET : natural := 16#b0#;  -- ro, 32 b, Read and clear the selected channel's fill status (used_now<<16 | used_most), MSI=(6<<16) will be sent if used_most changes
  constant c_channel_valid_count_GET    : natural := 16#b4#;  -- ro, 32 b, Read and clear the number of actions output by the selected subchannel, MSI=(4<<16|num) will be sent when the count becomes non-zero
  constant c_channel_overflow_count_GET : natural := 16#b8#;  -- ro, 32 b, Read and clear the number of actions which could not be enqueued to the selected full channel which were destined for the selected subchannel, MSI=(5<<16|num) will be sent when the count becomes non-zero
  constant c_channel_failed_count_GET   : natural := 16#bc#;  -- ro, 32 b, Read and clear the number of actions with the selected error code which were destined for the selected subchannel, MSI=(code<<16|num) will be sent when the count becomes non-zero
  constant c_channel_event_id_hi_GET    : natural := 16#c0#;  -- ro, 32 b, The event ID of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read (high word)
  constant c_channel_event_id_lo_GET    : natural := 16#c4#;  -- ro, 32 b, The event ID of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read (low word)
  constant c_channel_param_hi_GET       : natural := 16#c8#;  -- ro, 32 b, The parameter of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read (high word)
  constant c_channel_param_lo_GET       : natural := 16#cc#;  -- ro, 32 b, The parameter of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read (low word)
  constant c_channel_tag_GET            : natural := 16#d0#;  -- ro, 32 b, The tag of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read
  constant c_channel_tef_GET            : natural := 16#d4#;  -- ro, 32 b, The TEF of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read
  constant c_channel_deadline_hi_GET    : natural := 16#d8#;  -- ro, 32 b, The deadline of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read (high word)
  constant c_channel_deadline_lo_GET    : natural := 16#dc#;  -- ro, 32 b, The deadline of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read (low word)
  constant c_channel_executed_hi_GET    : natural := 16#e0#;  -- ro, 32 b, The actual execution time of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read (high word)
  constant c_channel_executed_lo_GET    : natural := 16#e4#;  -- ro, 32 b, The actual execution time of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read (low word)

  --| Component ------------------------- eca_auto --------------------------------------------|
  component eca_auto is
  generic(
    g_channels        : natural := 1;   --Number of channels implemented by the ECA, including the internal IO channel #0
    g_search_capacity : natural := 512; --Total number of search table entries per active page
    g_offset_bits     : natural := 32;  --Actions scheduled for execution with a delay in ticks exceeding offset_bits are executed early
    g_walker_capacity : natural := 256; --Total number of walker table entries per active page
    g_latency         : natural := 4096 --Delay in ticks (typically nanoseconds) between an event's arrival at the ECA and its earliest possible execution as an action
  );
  Port(
    clk_sys_i                   : std_logic;                            -- Clock input for sys domain
    rst_sys_n_i                 : std_logic;                            -- Reset input (active low) for sys domain
    channel_capacity_i          : in  std_logic_vector(16-1 downto 0);  -- Total number of actions which may be enqueued by the selected channel at a time
    channel_capacity_V_i        : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_capacity
    channel_deadline_hi_i       : in  std_logic_vector(32-1 downto 0);  -- The deadline of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read (high word)
    channel_deadline_hi_V_i     : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_deadline_hi
    channel_deadline_lo_i       : in  std_logic_vector(32-1 downto 0);  -- The deadline of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read (low word)
    channel_deadline_lo_V_i     : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_deadline_lo
    channel_event_id_hi_i       : in  std_logic_vector(32-1 downto 0);  -- The event ID of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read (high word)
    channel_event_id_hi_V_i     : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_event_id_hi
    channel_event_id_lo_i       : in  std_logic_vector(32-1 downto 0);  -- The event ID of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read (low word)
    channel_event_id_lo_V_i     : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_event_id_lo
    channel_executed_hi_i       : in  std_logic_vector(32-1 downto 0);  -- The actual execution time of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read (high word)
    channel_executed_hi_V_i     : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_executed_hi
    channel_executed_lo_i       : in  std_logic_vector(32-1 downto 0);  -- The actual execution time of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read (low word)
    channel_executed_lo_V_i     : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_executed_lo
    channel_failed_count_i      : in  std_logic_vector(32-1 downto 0);  -- Read and clear the number of actions with the selected error code which were destined for the selected subchannel, MSI=(code<<16|num) will be sent when the count becomes non-zero
    channel_failed_count_V_i    : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_failed_count
    channel_max_num_i           : in  std_logic_vector(8-1 downto 0);   -- Total number of subchannels supported by the selected channel
    channel_max_num_V_i         : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_max_num
    channel_mostfull_ack_i      : in  std_logic_vector(32-1 downto 0);  -- Read the selected channel's fill status (used_now<<16 | used_most), MSI=(6<<16) will be sent if used_most changes
    channel_mostfull_ack_V_i    : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_mostfull_ack
    channel_mostfull_clear_i    : in  std_logic_vector(32-1 downto 0);  -- Read and clear the selected channel's fill status (used_now<<16 | used_most), MSI=(6<<16) will be sent if used_most changes
    channel_mostfull_clear_V_i  : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_mostfull_clear
    channel_msi_get_enable_i    : in  std_logic_vector(1-1 downto 0);   -- Check if MSI messages are enabled for the selected channel
    channel_msi_get_enable_V_i  : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_msi_get_enable
    channel_msi_get_target_i    : in  std_logic_vector(32-1 downto 0);  -- Get the destination MSI address for the selected channel
    channel_msi_get_target_V_i  : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_msi_get_target
    channel_overflow_count_i    : in  std_logic_vector(32-1 downto 0);  -- Read and clear the number of actions which could not be enqueued to the selected full channel which were destined for the selected subchannel, MSI=(5<<16|num) will be sent when the count becomes non-zero
    channel_overflow_count_V_i  : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_overflow_count
    channel_param_hi_i          : in  std_logic_vector(32-1 downto 0);  -- The parameter of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read (high word)
    channel_param_hi_V_i        : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_param_hi
    channel_param_lo_i          : in  std_logic_vector(32-1 downto 0);  -- The parameter of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read (low word)
    channel_param_lo_V_i        : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_param_lo
    channel_tag_i               : in  std_logic_vector(32-1 downto 0);  -- The tag of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read
    channel_tag_V_i             : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_tag
    channel_tef_i               : in  std_logic_vector(32-1 downto 0);  -- The TEF of the first action with the selected error code on the selected subchannel, cleared when channel_failed_count is read
    channel_tef_V_i             : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_tef
    channel_type_i              : in  std_logic_vector(32-1 downto 0);  -- Type of the selected channel (0=io, 1=linux, 2=wbm, ...)
    channel_type_V_i            : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_type
    channel_valid_count_i       : in  std_logic_vector(32-1 downto 0);  -- Read and clear the number of actions output by the selected subchannel, MSI=(4<<16|num) will be sent when the count becomes non-zero
    channel_valid_count_V_i     : in  std_logic_vector(1-1 downto 0);   -- Valid flag - channel_valid_count
    error_i                     : in  std_logic_vector(1-1 downto 0);   -- Error control
    search_ro_event_hi_i        : in  std_logic_vector(32-1 downto 0);  -- Event IDs greater than or equal to this value match this search table record (high word)
    search_ro_event_hi_V_i      : in  std_logic_vector(1-1 downto 0);   -- Valid flag - search_ro_event_hi
    search_ro_event_lo_i        : in  std_logic_vector(32-1 downto 0);  -- Event IDs greater than or equal to this value match this search table record (low word)
    search_ro_event_lo_V_i      : in  std_logic_vector(1-1 downto 0);   -- Valid flag - search_ro_event_lo
    search_ro_first_i           : in  std_logic_vector(16-1 downto 0);  -- The first walker entry to execute if an event matches this record in the search table
    search_ro_first_V_i         : in  std_logic_vector(1-1 downto 0);   -- Valid flag - search_ro_first
    stall_i                     : in  std_logic_vector(1-1 downto 0);   -- flow control
    time_hi_i                   : in  std_logic_vector(32-1 downto 0);  -- Ticks (nanoseconds) since Jan 1, 1970 (high word)
    time_hi_V_i                 : in  std_logic_vector(1-1 downto 0);   -- Valid flag - time_hi
    time_lo_i                   : in  std_logic_vector(32-1 downto 0);  -- Ticks (nanoseconds) since Jan 1, 1970 (low word)
    time_lo_V_i                 : in  std_logic_vector(1-1 downto 0);   -- Valid flag - time_lo
    walker_ro_channel_i         : in  std_logic_vector(8-1 downto 0);   -- The channel to which the resulting action will be sent
    walker_ro_channel_V_i       : in  std_logic_vector(1-1 downto 0);   -- Valid flag - walker_ro_channel
    walker_ro_flags_i           : in  std_logic_vector(4-1 downto 0);   -- Execute the resulting action even if it suffers from the errors set in this flag register
    walker_ro_flags_V_i         : in  std_logic_vector(1-1 downto 0);   -- Valid flag - walker_ro_flags
    walker_ro_next_i            : in  std_logic_vector(16-1 downto 0);  -- The next walker entry to execute after this record (0xffff = end of list)
    walker_ro_next_V_i          : in  std_logic_vector(1-1 downto 0);   -- Valid flag - walker_ro_next
    walker_ro_num_i             : in  std_logic_vector(8-1 downto 0);   -- The subchannel to which the resulting action will be sent
    walker_ro_num_V_i           : in  std_logic_vector(1-1 downto 0);   -- Valid flag - walker_ro_num
    walker_ro_offset_hi_i       : in  std_logic_vector(32-1 downto 0);  -- The resulting action's deadline is the event timestamp plus this offset (high word)
    walker_ro_offset_hi_V_i     : in  std_logic_vector(1-1 downto 0);   -- Valid flag - walker_ro_offset_hi
    walker_ro_offset_lo_i       : in  std_logic_vector(32-1 downto 0);  -- The resulting action's deadline is the event timestamp plus this offset (low word)
    walker_ro_offset_lo_V_i     : in  std_logic_vector(1-1 downto 0);   -- Valid flag - walker_ro_offset_lo
    walker_ro_tag_i             : in  std_logic_vector(32-1 downto 0);  -- The resulting actions's tag
    walker_ro_tag_V_i           : in  std_logic_vector(1-1 downto 0);   -- Valid flag - walker_ro_tag
    channel_code_select_o       : out std_logic_vector(2-1 downto 0);   -- Read/clear this error condition (0=late, 1=early, 2=conflict, 3=delayed)
    channel_deadline_hi_RD_o    : out std_logic_vector(1-1 downto 0);   -- Read enable flag - channel_deadline_hi
    channel_deadline_lo_RD_o    : out std_logic_vector(1-1 downto 0);   -- Read enable flag - channel_deadline_lo
    channel_event_id_hi_RD_o    : out std_logic_vector(1-1 downto 0);   -- Read enable flag - channel_event_id_hi
    channel_event_id_lo_RD_o    : out std_logic_vector(1-1 downto 0);   -- Read enable flag - channel_event_id_lo
    channel_executed_hi_RD_o    : out std_logic_vector(1-1 downto 0);   -- Read enable flag - channel_executed_hi
    channel_executed_lo_RD_o    : out std_logic_vector(1-1 downto 0);   -- Read enable flag - channel_executed_lo
    channel_failed_count_RD_o   : out std_logic_vector(1-1 downto 0);   -- Read enable flag - channel_failed_count
    channel_mostfull_ack_RD_o   : out std_logic_vector(1-1 downto 0);   -- Read enable flag - channel_mostfull_ack
    channel_mostfull_clear_RD_o : out std_logic_vector(1-1 downto 0);   -- Read enable flag - channel_mostfull_clear
    channel_msi_set_enable_o    : out std_logic_vector(1-1 downto 0);   -- Turn on/off MSI messages for the selected channel
    channel_msi_set_enable_WR_o : out std_logic_vector(1-1 downto 0);   -- Write enable flag - channel_msi_set_enable
    channel_msi_set_target_o    : out std_logic_vector(32-1 downto 0);  -- Set the destination MSI address for the selected channel (only possible while it has MSIs disabled)
    channel_msi_set_target_WR_o : out std_logic_vector(1-1 downto 0);   -- Write enable flag - channel_msi_set_target
    channel_num_select_o        : out std_logic_vector(8-1 downto 0);   -- Read/clear this subchannel
    channel_overflow_count_RD_o : out std_logic_vector(1-1 downto 0);   -- Read enable flag - channel_overflow_count
    channel_param_hi_RD_o       : out std_logic_vector(1-1 downto 0);   -- Read enable flag - channel_param_hi
    channel_param_lo_RD_o       : out std_logic_vector(1-1 downto 0);   -- Read enable flag - channel_param_lo
    channel_select_o            : out std_logic_vector(8-1 downto 0);   -- Read/clear this channel
    channel_select_RD_o         : out std_logic_vector(1-1 downto 0);   -- Read enable flag - channel_select
    channel_select_WR_o         : out std_logic_vector(1-1 downto 0);   -- Write enable flag - channel_select
    channel_tag_RD_o            : out std_logic_vector(1-1 downto 0);   -- Read enable flag - channel_tag
    channel_tef_RD_o            : out std_logic_vector(1-1 downto 0);   -- Read enable flag - channel_tef
    channel_valid_count_RD_o    : out std_logic_vector(1-1 downto 0);   -- Read enable flag - channel_valid_count
    flip_active_o               : out std_logic_vector(1-1 downto 0);   -- Flip the active search and walker tables with the inactive tables
    search_rw_event_hi_o        : out std_logic_vector(32-1 downto 0);  -- Scratch register to be written to search_ro_event_hi
    search_rw_event_lo_o        : out std_logic_vector(32-1 downto 0);  -- Scratch register to be written to search_ro_event_lo
    search_rw_first_o           : out std_logic_vector(16-1 downto 0);  -- Scratch register to be written to search_ro_first
    search_select_o             : out std_logic_vector(16-1 downto 0);  -- Read/write this record in the inactive search table
    search_select_RD_o          : out std_logic_vector(1-1 downto 0);   -- Read enable flag - search_select
    search_select_WR_o          : out std_logic_vector(1-1 downto 0);   -- Write enable flag - search_select
    search_write_o              : out std_logic_vector(1-1 downto 0);   -- Store the scratch registers to the inactive search table record search_select
    walker_rw_channel_o         : out std_logic_vector(8-1 downto 0);   -- Scratch register to be written to walker_ro_channel
    walker_rw_flags_o           : out std_logic_vector(4-1 downto 0);   -- Scratch register to be written to walker_ro_flags
    walker_rw_next_o            : out std_logic_vector(16-1 downto 0);  -- Scratch register to be written to walker_ro_next
    walker_rw_num_o             : out std_logic_vector(8-1 downto 0);   -- Scratch register to be written to walker_ro_num
    walker_rw_offset_hi_o       : out std_logic_vector(32-1 downto 0);  -- Scratch register to be written to walker_ro_offset_hi
    walker_rw_offset_lo_o       : out std_logic_vector(32-1 downto 0);  -- Scratch register to be written to walker_ro_offset_lo
    walker_rw_tag_o             : out std_logic_vector(32-1 downto 0);  -- Scratch register to be written to walker_ro_tag
    walker_select_o             : out std_logic_vector(16-1 downto 0);  -- Read/write this record in the inactive walker table
    walker_select_RD_o          : out std_logic_vector(1-1 downto 0);   -- Read enable flag - walker_select
    walker_select_WR_o          : out std_logic_vector(1-1 downto 0);   -- Write enable flag - walker_select
    walker_write_o              : out std_logic_vector(1-1 downto 0);   -- Store the scratch registers to the inactive walker table record walker_select
    
    slave_i                     : in  t_wishbone_slave_in;
    slave_o                     : out t_wishbone_slave_out

    
  );
  end component;

  constant c_eca_slave_sdb : t_sdb_device := (
  abi_class     => x"0000", -- undocumented device
  abi_ver_major => x"01",
  abi_ver_minor => x"00",
  wbd_endian    => c_sdb_endian_big,
  wbd_width     => x"7", -- 8/16/32-bit port granularity
  sdb_component => (
  addr_first    => x"0000000000000000",
  addr_last     => x"00000000000000ff",
  product => (
  vendor_id     => x"0000000000000651",
  device_id     => x"b2afc251",
  version       => x"00000020",
  date          => x"20160408",
  name          => "ECA_UNIT:CONTROL   ")));

end eca_auto_pkg;
package body eca_auto_pkg is
end eca_auto_pkg;
